# DDD 基础

领域驱动设计（DDD） 是 Eric Evans 提出的一种软件设计方法和思想，主要解决业务系统的设计和建模。DDD 有大量难以理解的概念，尤其是翻译的原因，某些词汇非常生涩，例如：模型、限界上下文、聚合、实体、值对象等。

实际上 DDD 的概念和逻辑本身并不复杂，很多概念和名词是为了解决一些特定的问题才引入的，并和面向对象思想兼容，可以说 DDD 也是面向对象思想中的一个子集。如果遵从奥卡姆剃刀的原则，“如无必要，勿增实体”，我们先把 DDD 这些概念丢开，从一个案例出发，在必要的时候将这些概念引入。

## 从纸和笔思考 IT 系统的工作逻辑

让我真正对计算机软件和建模有了更深入的认识是在一家餐厅吃饭的时候。数年以前，我还在一家创业公司负责餐饮软件的服务器端的开发工作，因为工作的原因，外出就餐时常都会对餐厅的点餐系统仔细观察，以便于改进我们自己产品的设计。

一次偶然的情况，我们就餐的餐厅停电了，所幸是在白天，对我们的就餐并没有什么影响。我突然很好奇这家店，在收银系统无法工作的情况下怎么让业务继续运转，因此我饶有趣味的等待服务员来接受我们的点单。

故事的发展并没有超出预期，服务员拿了纸和笔，顺利的完成了点餐，并将复写纸复写的底单麻溜的撕下来交给了后厨。我这时候才回过神来。

**软件工程师并没有创造新的东西，只不过是数字世界的砖瓦工，计算机系统中合乎逻辑的过程，停电后人肉使用纸和笔一样合乎逻辑。**

合乎现实世界的逻辑和和规则，使用鼠标和键盘代替纸和笔，就是软件设计的基本逻辑。如果我们只是关注于对数据库的增、删、改、查（CRUD），实际上没有对业务进行正确的识别，这是导致代码组织混乱的根本原因。

会计、餐饮、购物、人员管理、仓储，这些都是各个领域实实在在发生的事情，分析业务逻辑，从中找出固定的模式，抽象成计算机系统中对象并存储。这就是 DDD 和面向对象思想中软件开发的一般过程。

你可能会想，我们平时不就是这样做的吗?

现实是，我们往往马上关注到数据库的设计上，想当然的设计出一些数据库表，然后着手于界面、网络请求、如何操作数据库上，业务逻辑被封装到一个叫做 Service 对象上，这个对象不承载任何状态，业务逻辑通过修改数据库实现。

![面向数据库的编程方法](02-ddd-foundamental/face2database.png)

一般来说这种方法也没有大的问题，甚至工作的很好，Fowler 将这种方法称作为 **事务脚本（Transaction Script）**。还有其他的设计模式，将用户界面、业务逻辑、数据存储作为一个“模块”，可以实现用户拖拽就可以实现简单的编程，.net、VF曾经提供过这种设计模式，这种设计模式叫做 SMART UI。

这种模式有一些好处。

- 非常直观，开发人员学习完编程基础知识和数据库 CRUD 操作之后就可以开发
- 效率高，能短时间完成应用开发
- 模块之间非常独立

麻烦在于，当业务复杂后，这种模式会带来一些问题。

虽然最终都是对数据库的修改，但是中间存在大量的业务逻辑，并没有得到良好的封装。客人退菜，并不是将订单中的菜品移除这么简单。需要将订单的总额重新计算，以及需要通知后厨尝试撤回正在制作中的菜。

不长眼的新手程序员擅自修改数据片段，整体业务逻辑被破坏。这是因为并没有真正的一个 “订单” 的对象负责执行相关的业务逻辑，`Sevice` 上的一个方法直接就对数据库修改了，保持业务逻辑的完整，完全凭程序员对系统的了解。

![业务逻辑一致性难以维护](02-ddd-foundamental/system-error-when-data-unconsistant.png)

我们在各个餐厅交流的时候，发现这并不是一个 IT 系统的问题。某些管理不良餐厅，所有的服务员都可以收银，而不是专门的收营员收银；收营员划掉菜品没有更新小计，另外的服务员结账时会发生错误。按照程序设计的语言来说，这些餐厅人员职责不清晰，不符合面向对象的一些原则。

我们吸收到这些业务逻辑到 IT 系统中来，并意识到系统中这里有一些隐藏的模型：

- 订单
- 菜品

我们决定，抽象出订单、菜品的对象，菜品不应该被直接修改，而是通过订单才能修改，无论任何情况，菜品的状态变化都通过订单来完成。

复杂系统的状态被清晰的定义出来了， `Service` 承担处理各个应用场景的差异，模型对象处理一致的业务逻辑。

在接触 Eric Evans 的 DDD 概念之前，我们没有找到这种开发模式的名字，暂时称作为 **朴素模型驱动开发**。

![朴素模型驱动开发](02-ddd-foundamental/simple_ddd_patten.png)


## 模型和领域模型

从上面的例子中，模型是能够表达系统业务逻辑和状态的对象。

模型是一个非常宽泛的概念，任何东西都可以是模型，我们尝试给模型下一个定义，并随后继续将领域模型的概念外延缩小。

**模型，用来反映事物某部分特征的物件，无论是实物还是虚拟的** 古人用八个卦象作为世界运行规律的模型；地图用线条和颜色作为地理信息的模型；IT 系统用 E-R 作为对象或者数据库表关系的模型；

我们知道要想做好一个可持续维护的 IT 系统，实际上需要对业务进行充分的抽象，找出这些隐藏的模型，并搬到系统中来。如果发生在餐厅的所有事物，都要能在系统中找到对应的对象，那么这个系统的业务逻辑就非常完备。

现实世界中的业务逻辑，在 IT 系统业务分析时，适合某个行业和领域相关的，所以又叫做领域。

**领域，指的特定行业或者场景下的业务逻辑**。

**DDD 中的模型是指反应 IT 系统的业务逻辑和状态的对象，是从具体业务（领域）中提取出来的，因此又叫做领域模型**。

通过对实际业务出发，而非马上关注数据库、程序设计。通过识别出固定的模式，并将这些业务逻辑的承载者抽象到一个模型上。这个模型负责处理业务逻辑，并表达当前的系统状态。**这个过程就是领域驱动设计。**

我从这里面学到了什么呢？

我们做的计算机系统实际上，是替代了现实世界中的一些操作。按照面向对象设计的话，我们的系统是一个电子餐厅。现实餐厅中的实体，应该对应到我们的系统中去，用于承载业务，例如收银员、顾客、厨师、餐桌、菜品，这些虚拟的实体表达了系统的状态，在某种程度上就能指代系统，这就是模型，如果找到了这些元素，就很容易设计出软件。

后来，如果我什么业务逻辑想不清楚，我就会把电断掉，假装自己是服务员，用纸和笔走一边业务流程。

分析业务，设计领域模型，编写代码。这就是领域驱动设计的基本过程。随后会介绍，如何设计领域模型，当我们建立了领域模型后，我可以考虑使用领域模型指导开发工作。

- 指导数据库设计
- 指导模块分包和代码设计
- 指导 RESTful API 设计
- 指导事务策略
- 指导权限
- 指导微服务划分（有必要的情况）

![领域驱动设计过程](02-ddd-foundamental/ddd-process.png)

在我们之前的例子中，收银员需要负责处理收银的操作，同时表达这个餐厅有收营员这样的一个状态。收营员收到钱并记录到账本中，账本负责处理记录钱的业务逻辑，同时表达系统中有多少钱的状态。

## 分析领域模型时，请把”电“断掉

我们进行业务系统开发时，大多数人都会认同一个观点：将业务和模型设计清楚之后，开发起来会容易很多。

但是实际开发过程中，我们既要分析业务，也要处理一些技术细节，例如：如何响应表单提交、如何存储到数据库、事务该怎么处理等。

使用领域驱动设计还有一个好处，我们可以通过隔离这些技术细节，先进行业务逻辑建模，然后再完成技术实现，因为业务模型已经建立，技术细节无非就是响应用户操作和持久化模型。

我们可以吧系统复杂的问题分为两类：

- 业务复杂度
- 技术复杂度

![技术复杂度和业务复杂度](02-ddd-foundamental/isolation.png)

**技术复杂度，软件设计中和技术实现相关的问题，例如处理用户输入，持久化模型，处理网络通信等。**

**业务复杂度，软件设计中和业务逻辑相关的问题，例如为订单添加商品，需要计算订单总价，应用折扣规则等。**

当我们分析业务并建模时，过于关注技术实现，会带来极大的干扰。我学到最实用的思维方法，就是在这个过程把”电“断掉，技术复杂度中的用户交互想象成人工交谈，持久化想象成用纸和笔记录。

DDD 还强调，业务建模应该充分的和业务专家在一起，不应该只是实现软件的工程师自嗨。业务专家是一个虚拟的角色，有可能是一线业务人员、项目经理、或者软件工程师。

由于和业务专家一起完成建模，因此尽量不要选用非常专业的绘图的工具和使用技术语言。 DDD 只是一种建模思想，并没有规定使用的具体工具。我这里使用 PPT 的线条和形状，用 E-R 的方式表达领域模型，如果大家都很熟悉 UML 也是可以的。甚至实际工作中，我们大量使用便利贴和白板完成建模工作。

这个建模过程可以是技术人员和业务专家一起讨论出来，也可以是使用 ”事件风暴“ 这类工作坊的方式完成。

这个过程非常重要，DDD 把这个过程称作 **协作设计**。

通过这个过程，我们得到了领域模型。

![领域模型v1](02-ddd-foundamental/ddd-v1.png)

上图使我们通过业务分析得到的一个非常基本的领域模型，我们的点餐系统中，会有座位、订单、菜品、评价几个模型。一个座位可以由多个订单，每个订单可以有多个菜品和评价。

同时，菜品也会被不同的订单使用。

## 上下文、二义性、统一语言

我们用这个模型开发系统，使用领域模型驱动的方式开发，相对于事务脚本的方式，已经容易和清晰很多了，但还是有一些问题。

有一天，市场告诉我们，这个系统会有一个逻辑问题。就是系统中菜品被删除，订单也不能查看。在我们之前的认知里面，订单和菜品是一个多对多的关系，菜品都不存在了，这个订单还有什么用。

菜品，在这里存在了致命的二义性！！！这里的菜品实际上有两个含义：

- 在订单中，表达这个消费项的记录，也就是订单项。例如，5号桌消费的鱼香肉丝一份。
- 在菜品管理中，价格为30元的鱼香肉丝，包含菜单图片、文字描述，以及折扣信息。

菜品管理中的菜品下架后，不应该产生新的订单，同时也不应该对订单中的菜品造成任何影响。

这些问题是因为，技术专家和业务专家的语言没有统一， DDD 认识到了这个问题，统一语言是实现良好的领域模型的前提，因此应该 ”大声的建模“。我在参与这个过程目睹过大量有意义的争吵，正是这些争吵让领域模型变得原来越清晰。

这个过程叫做 **统一语言**。

![领域模型v2](02-ddd-foundamental/ddd-v2.png)

和现实生活中一样，产生二义性的原因是因为我们的对话发生在不同的上下文中，我们在谈一个概念必须在确定的上下文中才有意义。在不同的场景下，即使使用的词汇相同，但是业务逻辑本质都是不同的。想象一下，发生在《武林外传》中同福客栈的几段对话。

![对话](02-ddd-foundamental/conversation.png)

这段对话中实际上有三个上下文，这里的 ”菜“ 这个词出现了三次，但是实际上业务含义完全不同。

- 大嘴说去买菜，这里的菜被抽象出来应该是食材采购品，如果掌柜对这个菜进行管理，应该具有采购者、名称、采购商家、采购价等。
- 秀才说实习生把账单中的菜算错了价格，秀才需要对账单进行管理，这里的菜应该指的账单科目，现实中一般是会计科目。
- 老白说的客人点了一个酱鸭，这里老白关注的是订单下面的订单项，订单项包含的属性有价格、数量、小计、折扣等信息。

实际上，还有一个隐藏的模型——上架中商品。掌柜需要添加菜品到菜单中，客人才能点，这个商品就是我们平时一般概念上的商品。

我们把语言再次统一，得到新的模型。

![DDD v3](02-ddd-foundamental/ddd-v3.png)

4个被红色虚线框起来的区域中，我们都可以使用 ”菜品“ 这个词汇（尽量不要这么做），但大家都明确 ”菜品“ 具有不同的含义。这个区域被叫做 **上下文**。当然上下文不只是由二义性决定的，还有可能是完全不相干的概念产生，例如订单和座位实际概念上并没有强烈的关联关系，我们在谈座位的时候完全在谈别的东西，所以座位也应该是单独的上下文。

识别上下文的边界是 DDD 中最难得一部分，同时上下文边界是由业务变化动态变化的，我们把识别出边界的上下文叫做**限界上下文（Bounded Context）**。限界上下文是一个非常有用的工具，限界上下文可以帮助我们识别出业务的边界，并做适当的拆分。

限界上下文的识别难以有一个明确的准则，上下文的边界非常模糊，需要有经验的工程师并充分讨论才能得到一个好的设计。同时需要注意，限界上下文的划分没有对错，只有是否合适。跨限界上下文之间模型的关联有本质的不同，我们用虚线标出，后面会聊到这种区别。

![DDD-v4](02-ddd-foundamental/ddd-v4.png)

使用上下文之后，带来另外一个收获。模型之间本质上没有多对多关系，如果有，说明存在一个隐含的成员关系，这个关系没有被充分的分析出来，对后期的开发会造成非常大的困扰。

## 聚合根、实体、值对象

上面的模型，尤其是解决二义性这个问题之后，已经能在实际开发中很好地使用了。不过还是会有一些问题没有解决，实际开发中，每种模型的身份可能不太一样，订单项必须依赖订单的存在而存在，如果能在领域模型图中体现出来就更好了。

举个例子来说，当我们删除订单时候，订单项应该一起删除，订单项的存在必须依赖于订单的存在。这样业务逻辑是一致的和完整的，游离的订单项对我们来说没有意义，除非有特殊的业务需求存在。

为了解决这个问题，对待模型就不再是一视同仁了。我们将那相关性极强的领域模型放到一起考虑，数据的一致性必须解决，同时生命周期也需要保持同步，我们把这个集合叫做**聚合**。

聚合中需要选择一个代表负责和全局通信，类似于一个部门的接口人，这样就能确保数据保持一致。我们把这个模型叫做**聚合根**。当一个聚合业务足够简单时，聚合有可能只有一个模型组成，这个模型就是聚合根，常见的就是配置、日志相关的。

相对于非聚合根的模型，我们叫做**实体**。

![DDD-v5](02-ddd-foundamental/ddd-v5.png)

我们把这个图完善一下，聚合之间也是用虚线链接，为聚合根标上橙色。识别聚合根需要一些技巧。

- 聚合根本质上也是实体，同属于领域模型，用于承载业务逻辑和系统状态。
- 实体的生命周期依附于聚合根，聚合根删除实体应该也需要被删除，保持系统一致性，避免游离的脏数据。
- 聚合根负责和其他聚合通信，因此聚合根往往具有一个全局唯一标识。例如，订单有订单 ID 和订单号，订单号为全局业务标识，订单 ID 为聚合内关联使用。聚合外使用订单号进行关联应用。

还有一类特殊的模型，这类模型只负责承载多个值的用处。在我们饭店的例子中，如果需要对账单支持多国货币，我们将纯数字的 `price` 字段修为 `Price` 类型。

```java

public clsss Price(){
    private String unit;
    private BigDecimal value;    
    
    public Price(String unit,BigDecimal value){
        this.unit = unit;
        this.value = value;
    }
}

```

价格这个模型，没有自己的生命周期，一旦被创建出来就无须修改，因为修改就改变了这个值本身。所以我们会给这类的对象一个构造方法，然后去除掉所有的 `setter` 方法。

我们把没有自己生命周期的模型，仅用来呈现多个字段的值的模型和对象，称作为**值对象**。

值对象一开始不是特别好理解，但是理解之后会让系统设计非常清晰。”地址“是一个显著的值对象。当订单发货后，地址中的某一个属性不应该被单独修改，因为被修改之后这个”地址“就不再是刚刚那个”地址“，判断地址是否相同我们会使用它的具体值：省、市、地、街道等。

值对象是相对于实体而言的，对比如下。

| 实体                   | 值对象                          |
| ---------------------- | ------------------------------- |
| ID 有意义              | ID 无意义（可能用于存储或引用） |
| 有自己的生命周期       | 一经创建就不要修改              |
| 可以对实体进行管理     | 使用新的值对象替换              |
| 使用 ID 进行相等性比较 | 使用属性进行相等性比较          |

另外值得一提的是，一个模型被作为值对象还是实体看待不是一成不变的，某些情况下需要作为实体设计，但是在另外的条件下却最好作为值对象设计。

地址，在一个大型系统充满了二义性。

- 作为订单中的收货地址时，无需进行管理，只需要表达街道、门牌号等信息，应该作为值对象设计。为了避免歧义，可以重新命名为收货地址。
- 作为系统地理位置信息管理的情况中具有自己的生命周期，应该作为实体设计，并重命名为系统地址。
- 作为用户添加的自定义地址，用户可以根据 ID 进行管理，应该作为实体，并重命名为用户地址。

我们使用蓝色区别实体和聚合根，更新后的模型图如下：

![ddd-v6](02-ddd-foundamental/ddd-v6.png)

虽然我们使用 E-R 的方式描述模型和模型之间的关系，但是这个 E-R 图使用了颜色、虚线，已经和传统的 E-R 图大不相同，把这种图暂时叫做 **CE-R** 图（Classified Entity Relationship）。DDD 没有规定如何画图，你可以使用其他任何画图的方法表达领域模型。

## 使用领域模型指导程序设计

在了解到 DDD 之前，到底该用一对多和多对多关系？RESTful API 设计时到底应该选哪一个对象作为资源地址，评价应该放到订单路径下还是单独出来？订单删除相关有多少对象应该纳入事务管理？

在没有领域模型之前，这些大概率凭借经验决定，当我们把领域模型设计出来之后，领域模型可以帮助我们做出这些指导。领域模型不只是为编写业务逻辑代码使用，这样对领域模型来说就太可惜了。

下面是领域模型指导软件开发的一些方面，具体细节后面会再逐个讨论。

### 指导数据库设计

通过 CE-R 图，我们明显可以设计出数据库了。不过还有一些细节需要注意。

首先，在之前的认知里面，多对多关系是非常正常的。但是通过对领域模型的分析后发现，传统处理多对多关系时，需要额外增加一张关联表，这张关联表本质上是一个”关系“的实体没有被发掘出来。否则，在实际开发中会造成系统耦合，以及使用 ORM 的时候产生困惑。

菜品和订单之间是多对多关系吗？

如果是，菜品和订单之间耦合了。实际上，菜品的管理处于系统操作的上游，菜品不依赖订单的任何操作，也就是说订单的任何变化菜品无需关心。

订单拥有多个订单项，每个订单项从菜品读入数据并拷贝，或者引用一个菜品的全局 ID （菜品在另外一个聚合）。这样在设计表结构时订单和订单项关联，订单项不关联菜品。订单项应该从程序读取菜品信息。看起来多对多的关系，被细致分析后，变成了一个一对多关系。

![数据库设计](02-ddd-foundamental/database-design.png)

在使用 ORM 时，良好的领域模型尤其有用。不合适的关联关系不仅让 ORM 关联变得混乱，还会让 ORM 的性能变差。

使用领域模型建立数据库的要点：

- 留意多对多关系，并拆解成一对多关系
- 值对象和实体往往为一对一关系
- 使用 ORM 时，聚合根和实体可以配置为级联删除和更新
- 禁止聚合根之间进行关联

### 指导 API 设计

RESTful API 已经变成了主流 API 设计方式，当设计好领域对象后，设计 API 的难度大大降低。

使用聚合根作为 URI 的根路径，使用实体作为子路径。通过 ID 作为 Path 参数。

![API 设计](02-ddd-foundamental/api-design.png)

值对象没有 ID，应该只能依附于某个实体的路径下做更新操作。

![API 设计 v2](02-ddd-foundamental/api-design-v2.png)

另外根据这个关系，处理批量操作的时候应该在实体的上一级完成，例如批量添加订单的订单项，可以设计为：

```
POST /orders/{orderId}/items-batch
```

不要设计为:

```
POST /orders/{orderId}/items/batch
```

### 指导对象设计

在实践中过程中，像 Java、Typescript具有类型系统的语言，对象很容易被误用。如果 `User` 对象既被拿来当做数据库操作使用，又被拿来当做接口呈现使用，这个类最终变成了上帝类，存在大量可有可无的属性。

例如用户注册时候需要输入重复密码，如果在 `User` 对象中添加 `confirmPassword` 属性，存储时候确并不需要。

因此 DDD 中，数据库各种对象的使用应该针对不同的场景设计。回到我们上面说的技术复杂度和业务复杂度中来。领域模型解决业务复杂度的问题，领域模型只应该被用作处理业务逻辑，存储、业务表现都应该和领域模型无关。

![对象设计](02-ddd-foundamental/objects-design.png)

简单来说，可以把这些 `Plain Object` 分为三类:

- DTO，和交互相关或者和后端、第三方服务对接
- Entity，数据库表映射
- Model，领域模型
  

另外，在使用领域模型使用上也需要额外注意

- 领域对象尽量使用组合的方式，而不是继承，现实业务逻辑中继承这种概念实际上很少。例如菜品的设计，有热菜、汤菜、凉菜，实际上这里面并不是菜的继承，而应该抽象出分类这个模型。
- 不要滥用领域模型，有些业务逻辑，实在找不出一个领域模型很正常，所以 DDD 中存在一个领域服务。例如，生成一个 UUID。有些业务逻辑不持有系统业务状态，Eric 的书中比喻为像加油站一样的业务逻辑。

### 指导代码组织

代码组织，通俗来说就是如何分包。一种狭义的对 DDD 的理解就是指按照 DDD 风格进行代码组织，虽然 DDD 的内容远不止于此。

在很长一段时间，我对 DDD 分包策略陷入困惑，后来我明白到，讨论 DDD 风格的分包，必须将单体引用和微服务应用分开考虑。

> 微服务应用在逻辑上和解耦良好的单体应用是一致的。

但是微服务是一种分布式架构，映射到单体应用中，各个包分布到不同的服务器中了。我们先以单体应用入手，最后再讨论如何将单体应用架构映射到到微服务中。

在事务脚本的模式中，我们一般将代码分为三层架构。DDD 特别的抽离出一层叫做 `application`。这一层是 DDD 的精华，领域模型关心业务逻辑，但是不关心业务场景。

`application` 用来隔离业务场景，显得非常重要。举个例子，用户被添加到系统中，领域模型处理的是：

1. 用户被添加
2. 授予基本权限
3. 积分规则创建
4. 账户创建（三户模型，客户、用户、账户往往分开）
5. 客户资料录入

但是，用户被添加到系统中由多个应用场景触发。

- 用户被邀请注册
- 用户自己注册
- 管理员添加用户

`application` 需要隔离应用场景，并组织调配领域服务，才能使得领域服务真正被复用。因此 `application` 需要承担事务管理、权限控制、数据校验和转换等操作。当领域服务被调用时，应该是纯粹业务逻辑，并与场景无关。

如果我们将三层架构和 DDD 架构对比，DDD 架构如右图所示。

![三层架构对比](02-ddd-foundamental/ddd-vs.png)

我们将 DDD 的代码架构展开，可以看到更为细节的内容。 DDD 代码实现上需要 `Repository`、`Factory` 等概念，但这些是可选的，我们在后面具体讲代码结构的部分再阐述。

![单体DDD架构](02-ddd-foundamental/ddd-mono.png)

我们再来看，DDD 的单体应用架构映射到微服务架构下会是怎么样的。

![单体到微服务](02-ddd-foundamental/mono-micro-service.png)

微服务必须考虑到不再是一个服务，`Domain` 层被抽离出来作为 `Domain Server` 存在，`Domain Server` 不关心业务场景，因此不需要 `application` 层。`Application Server` 需要 `Application` 层，`Domain` 层由后端的 `Domain Server` 提供。

另外补充，一些 DDD 代码组织的基本逻辑：

* 隔离业务复杂度和技术复杂度
* 使用接口隔离有必要的耦合和依赖倒置



## 在分布式系统中使用 DDD

在使用 DDD 的思想时，最让人迷惑的就是如何组织代码，也就是通常所说的系统架构的问题。在前面提到 DDD 可以很好地指导代码组织，其中举了两个例子，单体和微服务架构下 DDD 如何指导代码的组织方式。令人沮丧的是，大部分应用系统既不是完全的单体系统，也不是纯粹的微服务架构，而是出于某种中间状态。



无论我们使用单体、SOA、微服务、中台或者其他架构，都需要解决如何组织代码这个问题，DDD 并不是一个技术，而是指导我们组织代码的一种思想，这种思想也并不是凭空出现的。



就代码组织这个问题，看起来没有什么技术含量，但实际上非常重要，软件工程发展过程中出现过三次危机，软件危机泛指在计算机软件的开发和维护过程中所遇到的一系列严重问题，代码的组织和大规模协作是其重要的组成部分。



1. **结构化程序设计解决了第一次软件危机。**60年代~70年代计算机刚刚投入商业使用，主要的编程方式还是汇编语言在特定的机器上编写程序。当软件规模较小，基本上处于计算机科学家个人编码设计、使用的方式。随着软件规模扩大，复杂度增加，依赖特定机器、无结构化的编程方式无法应对软件的发展，带来了第一次软件危机。为了克服这个问题，业界提出了”软件工程“的概念，1972 年 C 语言的出现，解决了代码结构化、抽象性、可移植的问题。

2. **面向对象解决了第二次软件危机**。随着软件在商业中大规模使用，软件变得原来越复杂，即使结构化的 C 语言也无法满足业界对可维护性、可拓展性的需求。标志性的事件是 IBM 公司开发的 OS/360 系统失败，该系统有 4000 多个模块，约 100 万条指令，以及大量的 bug。面向对象的编程语言，Java、C#、C++ 出现，面向对象带来了更自然地代码组织方式，软件开发变得越像建筑业。
3. **第三次软件危机**。第三次软件危机还没有一个明确定义，通常来说就是互联网行业兴起，软件变得越来越复杂，需求越来越多变。软件开发从建筑业变成了服务业，需要随时响应变化，在软件行业表现为瀑布开发越来越不可行，敏捷开发越来越重要。从技术上表现为单机开发越来越不可行，分布式系统是必然的趋势。



每一次危机的解决，都是建立在前一次的基础之上的。面向对象是建立在结构化程序设计之上的，敏捷也是建立在瀑布之上的，而不是推翻前者。DDD 还停留在面向对象这个阶段，可以用来指导分布式系统设计，应对越来越复杂的应用系统，DDD 也不是面向对象思想的替代者。



DDD 的代码组织形式众说纷纭，并没有一个标准的代码架构。为什么会这样呢？实践中我们发现，不同公司、项目的业务背景不一致，架构不一致，架构的演化层次不一样（查看另外一篇文章《架构的演进》），标准的代码架构并不适合每一个公司。



当我们的系统架构从单体往 SOA、微服务、中台演变，无论名称如何变化，实际上都是分布式系统，只不过分布式的程度不一致而已。所以我们需要将问题拓展到分布式系统这个更大的概念上，再来谈 DDD 的代码组织形式才有意义。



我们看一下分布式系统下一个定义：

> 分布式系统是一组电脑，透过网络相互连接传递消息与通信后并协调它们的行为而形成的系统。——维基百科

从广义的分布式系统定义上来看，现在的互联网应用基本上没有不是分布式的了。分布式系统不是软件工程师主动选择的结构，而是业务逼得这样选择。阿里巴巴带动的去 IOE （去掉IBM的小型机、Oracle数据库、EMC存储设备，代之以自己在开源软件基础上开发的系统）就是一个很好的体现。



在这样的一个思维方式下，单体系统是只有一个计算节点的分布式系统，那么 DDD 在单体应用下的经验也可以应用起来。我没有找到一个专业术语描述分布式系统程度，这里请允许我创造一个新词，**分布式级别。** 

### 分布式级别

为了解决业务上的问题，用户量大、业务规模大，当用户量增长到无法被容忍时，我们引入分库分表（分布式数据库）、垂直拆分业务（微服务）。



我们会将系统变得越来越复杂，然后不得不解决各种分布式系统下的新问题，业务上面临的问题被转移到技术上，从而业务才有可能持续性的发展。我们面临的问题不会消失，只会从一个地方转移到另外一个地方，转移到我们能容忍的地方，比如转移到云上，然后通过购买服务解决。



系统中节点角色越少，需要解决的分布式问题则越少，可以认为这是**低级别的分布式系统**。低级别的分布式系统 架构基本上没有什么分布式问题存在，目前主流的小项目通过 Nginx 让应用水平拓展 + 主从数据库的架构可以看做低级别的分布式系统。



系统中节点的角色越多，应用垂直拆分，需要解决的分布式问题就越多，遇到的技术挑战也越多，我们可以认为这是**高级别的的系统**。应用系统的例子就是微服务架构，另外一个例子就是大数据平台。



我把分布式级别做了如下划分，基本上可以囊括目前互联网应用系统的主流架构：



- 准单体系统
- 低级别分布式系统
- 高级别分布式系统
- 复杂分布式系统



| 分布式级别       | 案例 | 架构参考 | 业务价值 | 分布式系统问题 |
| ---------------- | ---------------- | ---------------- | ---------------- | ---------------- |
| 准单体系统      | 博客系统<br/>内网 OA 软件 | LAMP<br>Java单体 | 简单、成本低 | 无分布式问题 |
| 低级别分布式系统 | 小型互联网产品 | Nginx 负载均衡<br/>Redis 分布式会话<br/>读写分离<br />RDS | 应用水平拓展<br/>存储水平拓展 | 高可用问题<br/>动态负载均衡问题<br/>监控问题 |
| 高级别分布式系统 | 中型互联网产品 | SOA<br/>微服务<br/> | 应用垂直拓展<br/>存储垂直拓展 | 上一级别所有问题<br/>分布式事务<br/>关联查询<br/>服务发现<br/>熔断降级<br/>调用链跟踪 |
| 复杂分布式系统   | 大型互联网产品<br/>大数据平台 | 中台 | 各个服务独立演进<br/>业务复用 | 上一级别所有问题<br/>版本化问题<br/>团队协作问题<br/>性能开销 |



在微服务项目中经历过痛苦的开发者应该所有体会，全世界开发者贡献了大量的开源软件尝试解决这些问题，后面详细介绍每一个问题如何具体解决。



### 清醒的使用 DDD

上面这些分布式系统的问题，DDD 都解决不了。DDD 的作用只有一个：**在单体中划分模块，在分布式系统中划分服务。** 服务划分的良好，关联查询、授权、分布式一致性等问题可以被很好的解决，也就是我们常常说的**解耦**。



但是就这一个作用，对于做应用开发的业务系统来说至关重要，虽然对于专门解决技术复杂度问题的云厂商来说用处不大，所以最好让 DDD 在合适的地方发挥作用。高级别的微服务系统的修改成本如此之高，以至于服务划分错误几乎没有能力调整回来，甚至导致很多互联网公司就此走向失败。



因此，如何划分服务，这是 DDD 非常有价值的一个地方，在分布式系统中，DDD 起到的作用实际上就是指导垂直拓展。值得庆幸的是，应用系统分布式级别增加带来很多技术挑战，但是逻辑上的架构变化却不大。



在每一个不同的演化层次下，谈 DDD 的代码架构才有意义。例如单体系统没有必要过多分层，避免样板代码大量出现；微服务系统则需要小心分层，并严格执行，否则修改成本非常高。另外也需要解决该层次下的技术问题，微服务需要解决分布式事务问题、分布式授权问题、分布式缓存问题、性能问题等。



#### DDD 分层和职责

在 DDD 指导代码设计部分，我们提到了三层架构和 DDD 的四层架构的区别，DDD 的四层架构被越来越多的认可，但是每层具体的职责很少有文章谈到。根据实践经验，我把四层模型中具体的职责整理出来，用于团队在做架构设计中能有共同的认识。



前面的 DDD 四层模型的图为了表达每层中的元素，丢失了一个重要的角度，每一层的组件可能有多个。还是以收银机系统为例，架构会是像下面这样，业界大多数互联网架构图也是这样画的，只是使用术语略有不同。

![image-20200505112134088](02-ddd-foundamental/image-20200505112134088.png)



实践中我们发现，接入层是由应用场景解决的，因此接入层需要在特定应用场景下使用。收银机应用下，接入层是 Restful  API 以及 socket 连接实现的实时通信，商户管理和平台管理无需使用这些接入方法，在不前后端分离的情况下，模板引擎也足够使用。

同样的，基础设施层是和领域层绑定到一起用于实现业务逻辑和规则，底层基础设施的选择由领域层决定。商品服务主要是和数据库打交道，需要使用 Mybatis，但是用户认证服务（图上未体现）可能只需要 Redis 做分布式会话即可。

接入层和技术设施层，更应该看做两个亚层。结合 DDD 术语将示例图调整如下：

![image-20200505111729710](02-ddd-foundamental/image-20200505111729710.png)



#### 应用层

餐饮系统是一个非常复杂，具有多端、多租户的系统，往往有收银机应用、手机点餐应用、商户管理、平台管理等应用，从而组合成一个系统。在有些公司的语境里，应用层往往是根据用户角色划分的，被称为”业务面“。



应用层的特点：

- 关心处理完一个完整的业务

- 该层只负责业务编排，对象转换，实际业务逻辑由领域层完成

- 不关心请求从何处来，但是关心谁来、做什么、有没有权限做

- 集成不同的领域服务解决问题

- 最终一致性（最终一致性对业务有侵入）事务放到这层

- 对应到分布式系统中的中台等概念

- 方法级别的功能权限控制放到这层

- 只产应用异常，对应 HTTP 状态码 403、401

- 准单体系统下，按照应用划分模块

  

#### 接入层

对接入层来说，我们可以看到，实际上接入层是依附于应用层存在的，随着前后端分离，Restful API 成了主流，对简单的系统来说这一层越来越弱化。对于有终端接入的系统来说，接入层并不简单，需要处理各种协议适配：XMPP、websocket、MQTT 等。在复杂度不高的情况下，我们往往把接入层和应用层合并部署，这里往往凭经验来决定。如果对分布式级别有了认识，可以更为科学的选择是否要将接入层和应用部署到一起。



接入层的特点：

- 关心视图和对外的服务，Restful、页面渲染、websocket、XMPP 连接等
- 如果没有多种接入方式，可以和应用层合并
- 对应到分布式系统中的网关、BFF、前台等概念
- 只产生接入异常，例如数据校验，对应 HTTP 状态码 400、415 等
- 一个应用可以有多个接入层
- 接入层做和业务规则无关的 bean validation 验证
- 准单体系统下，按照连接方式分包



#### 领域层

对于领域层来说，很多互联网公司没有这个概念，将这些实现混合在应用层隐藏实现了，造成业务规则不一致。随着前后端分离的发展，2013 年左右我也开始前后端分离实践，接入层剥离出去后，后端开发者开始审视是否需要抽象出一层来复用业务逻辑。当时大部分互联网公司称为服务，也就是 SOA 架构，大量使用  XML 和 SOAP 技术。

领域层的特点：

- 不关心场景，关心模型完整性和业务规则

- 不关心谁来，不关心场景完整的业务，关心当前上下文的业务完整

- 强一致性事务放到这层，聚合的事务是 "理所当然的"

- 对应到分布式系统中的 domain service、后台等概念

- 领域层做业务规则验证

- 产生业务规则异常，例如用户退款条件不满足，对应状态码 412、419 等

- 数据权限放到这层（比如只允许删除自己创建的商品），因为数据权限涉及业务规则

- 准单体系统下按照上下文分包，上下文之间调用**必须**走领域 domain service，目的就是解耦

- 上下文中分聚合，聚合根要足够小，只允许聚合根拥有对应的 domain service

- 根据业务情况，参考反范式理论，跨上下文使用值对象做必要的数据冗余

  

#### 基础设施层

对于基础设施层来说，技术设施层并不是指 MySQL、Redis 等外部组件，而是外部组件的适配器，Hibernate、Mybatis、Redis Template 等，因此在 DDD 中适配器模式被多次提到，基础设施层往往不能单独存在，还是要依附于领域层。技术设施层的适配器还包括了外部系统的适配，互联网产品系统的外部系统非常多，常见的有活体监测、风控系统、税务发票等。



技术设施层的特点：

- 关心存储、通知、第三方系统等外部设施（防腐层隔离）

- 如果使用自动化的 ORM，这层可以在一定程度上省略

- 基础设施异常，应丢出内部异常，对应状态码 500

- 准单体系统下按照 adapter 分包

- 基础设施的权限由配置到应用的凭证控制，例如数据库、对象存储的凭证，技术设施层不涉及用户的权限

  

#### DDD 分层的注意事项

DDD 分层架构需要认识到一点是，有时候我们在项目中找不到每层之间的明显的界限，那是因为我们使用的框架帮我们完成某一层。MVC 框架，Spring MVC、Jersey 帮我们搞定了接入层的事情，Hibernate、Redis Template 让我们感觉不到基础设施层。四层模型并不是一个刻板的教条，应该和你选用的框架做出调整，DDD 的作者也多次强调这一点。



另外，基础设施层和接入层需要注意两点：

- 接入层指的是服务端用于适配端侧的部分，而非端侧本身。因为接入层本来就依赖应用层，没有人使用接口在这里做依赖倒置，所有又被称作主动适配。
- 基础设施层指的是适配基础设施的部分，而非基础设施本身。开发者往往希望数据访问的接口有应用来定义，避免和基础设施绑定，提供替换的可能，因此这里往往大量使用接口，会有一些依赖倒置的实现，所以又被称作为被动适配。关于依赖倒置的知识，可以了解面向对象的一些基础概念。



### DDD 分层到四种架构的映射

我们把这四层合到一起部署就是准单体系统，分开部署就是微服务、SOA。

更加有意思的是，在准单体系统中，如果我们严格限定领域层中模块之间的耦合关系，应用层访问领域层是通过本地方法调用的。当我们想改造成微服务实现时，只需要简单的抽象一个接口，然后通过远程调用实现它，无论是 RPC、还是 Restful 访问都不是大问题。

当然我们得解决远程调用后的一系列问题，以及领域层是解耦良好的。



#### 准单体系统

准单体系统架构下，所有的代码在一个代码仓库，四层架构依然，往往通过多模块组织代码。应用层通过不同的模块实现，然后将领域服务抽出来一个公用模块。很多小型项目依然保持这种形态，每层能保持良好的依赖关系非常重要。 每层之间最好依次向下调用，DDD 的书中有一个不好的示例，上层可以跳过中间层直接调用下层。

![image-20200505123131815](02-ddd-foundamental/image-20200505123131815.png)

很多内网部署的传统项目单机就能满足，小型公司的 OA 软件、餐饮软件、会员管理系统的单机版就是通过这种方式部署。



#### 低级别分布式系统



![image-20200505124048034](02-ddd-foundamental/image-20200505124048034.png)

将应用水平拓展，数据库进行主从拆分，Redis 使用主从或哨兵模式，本质上和准单体系统没有区别，应用没有垂直拓展复杂性不会有特别大的提升。



还有一种折中的方式，应用层各个模块单独部署，领域层的业务逻辑单独部署或者通过 Jar 包的方式加载应用中，实现应用层的解耦，并且不会带来分布式的问题。



![image-20200505130402741](02-ddd-foundamental/image-20200505130402741.png)


基于上面这种模式的变体，下面这种部署方式也有很多，通过这种部署方式，领域服务使用严谨的 Java 实现，接入层和应用层使用 PHP、Nodejs 等动态语言实现。

![image-20200505130840667](02-ddd-foundamental/image-20200505130840667.png)

#### 高级别分布式系统 

如果我们把应用和领域层都独立部署，就得到了现在主流的微服务架构。只不过在微服务的语境下，应用层 + 接入层被称为 BFF （Backend for Frontend），领域层负责实现业务逻辑，应用层用于各种业务场景下的适配。

![image-20200505151228368](02-ddd-foundamental/image-20200505151228368.png)

然而这种设计会受到一些批评，他们认为这不是正宗的微服务，而像现在所说的中台。部分微服务的工程师倡导使用 API Gateway 的方式将领域服务的 API 直接暴露给端侧。



实际上这种做法应用层并没有消失，编排领域服务 API 的职责被下放到端侧，在一些特殊的业务场景下没有问题，但是大多数场景下并不合适。业务逻辑容易造成碎片化，存在调用次数多，服务间最终一致性事务难以实现等问题。下面这张图表达了这种设计方式，但大多数情况下并不推荐。

![image-20200505151818133](02-ddd-foundamental/image-20200505151818133.png)



到此，领域层被垂直拆分，随之而来的就是我们熟知的各种分布式问题了，熔断、负载均衡等问题属于技术复杂度可以在业务无感知的情况下被解决，但下面几个问题需要侵入业务才能被良好的解决，因此还需要 DDD 的帮助。



- 领域层模块之间的事务怎么处理？
- 领域层模块之间需要表关联怎么办？
- 领域层是无状态的，怎么做权限控制？
- 领域层模块之间的依赖关系怎么处理？



我们在后面的 《DDD 指导应用垂直拆分后的问题》部分回答。



#### 复杂分布式系统

高级别的分布式系统已经是业界大的互联网公司的主流做法，不过在一些极端复杂的系统中，依然不能满足业务需要。倒不是技术上一定要拆的非常细，主要是参与开发的人数多、代码量大，团队协作、版本构建有很多问题。

一个最佳的敏捷团队为 10 到 15人，除去测试、业务分析师，开发者一般在 10 人左右。因此在非常复杂的系统中尽可能把能拆分的都拆出去。继续拆分往往有两个方向：



1. 变得复杂的接入层，在应用层里面兜不住了。例如  socket 连接相当费资源，可以剥离出去单独建立连接，然后和收银机应用通信。
2. 一些外部系统的适配层，例如短信网关、税务系统适配服务。



![image-20200505161853912](02-ddd-foundamental/image-20200505161853912.png)

某大型 lot 平台将对接端侧的服务根据接入协议拆分，HTTP、MQTT、XMPP 然后转换数据格式后统一送入。不过，这种场景已经比较少见。



### DDD 指导应用垂直拆分后的问题



应用垂直拆分好处是带来良好的拓展性，代价是需要解决一系列问题。其中分布式事务设计、表关联问题、分布式授权问题、服务间依赖问题需要依靠 DDD 把服务拆分好就能妥善解决之外，其他问题例如熔断降级则和服务拆分没有较大联系。这部分讨论解决这几个问题的思路和理论基础，具体的实现放到后面详细方案设计中呈现。



#### 分布式事务设计

服务被垂直拆分后，如何解决事务问题是一个业界难题。很多讲架构的书都会讲两阶段提交、三阶段提交、TCC模式、Saga 长时处理，然而并没有说明什么场景下该选用什么架构。

其实我们一直都在和分布式事务打交道，银行、典型业务有一个概念叫做”冲正“。意思是对错误、或者不一致的情况出现时进行纠正，和数据库事务的回滚类似。和第三方支付系统对接时，支付系统会同步或者异步回调，回调失败后会反复重试。



和外部系统对接，本质上就是构成了一个分布式系统，其一致性问题就是分布式系统。但这种一致性问题和我们在数据库事务不能完全等同，数据事务是强一致性，满足 ACID 的特性。分布式系统事务参考 BASE 思想，保证最终可用即可。



根据 CAP 定理，分布式系统中一致性、可用性、分区容忍性是矛盾的，只能三者取二。因此分布式事务的最佳解决方法是：**服务间使用柔性事务（AP），服务内使用强一致性事务（CA）。** 解决这个问题，需要了解几个基本理论：CAP 定理、ACID 原理、BASE 思想、幂等原理。



**CAP 定理**



数据库随着服务垂直拆分后，单机系统的事务规则不再满足。分布式系统的 CAP 定理包含三个元素：



- C: Consistency，一致性。系统中所有的数据备份、分区，在同一时刻具有同样的值。
- A: Availability，可用性。系统收到请求后，必须完成响应，否则就是不满足可用性。
- P: Partition tolerance，分区容忍性。每个节点可以视为一个区，可以允许分区之间通信失败。通俗的来说，由于人类通信技术条件限制，如果是分布式系统，就具备分区容忍性。



![CAP Theorem 2](02-ddd-foundamental/CAP-Theorem-last.jpg)



CAP 定理的本质是阐述了网络通信的不可靠传输，技术上无法突破，但是可以从业务上取舍。关系型数据库都选择 CA，保证业务可用和一致性问题，不接受分区容忍，也就是说网络断开就不再工作。



因此服务内就是一个单体，可以从容的选择强一致性事务。而服务间无法突破 CAP 定理的限制，可以通过各种手段达到最终一致性，而最终一致性的各种方案非常成熟。



**ACID**



- A:Atomicity，原子性是指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做。
- C: Consistency，一致性是指事务执行前后，数据处于一种合法的状态，最终状态不会出现。
- I:Isolation，隔离性是指多个事务并发执行的时候，事务内部的操作与其他事务是隔离的，相互之间不受影响。
- D:Durability，持久性是指事务一旦提交，它对数据的改变就应该是永久性的，机器故障或断电都不会丢失数据。



ACID 约束了数据库具有一致性和可靠性优先，主流关系型数据都支持 ACID 特性，但是需要注意 MongoDB、Redis 等数据库是不支持的，不应该完全依赖它们存放交易数据。



**BASE 事务原理**

BASE 思想相对于 ACID 可以指导分布式系统中柔性事务设计， BASE 包含三个元素：

- BA:BasicallyAvailable，基本可用。
- Soft-state，软状态/柔性事务，允许系统在一定时间之内存在不一致的情况，这种状态叫做软状态。
- Eventually Consistent，最终一致性，经过一段时间之后，更新的数据会到达系统中所有的节点，这段时间被称为最终一致性时间窗口。

BASE 思想更契合我们做服务拆分的目标，分而治之，实现弹性拓展。例如订单支付完成之后，允许一段时间后，订单状态最终被标记为被支付。**BASE 事务原理在实际开发中最难的不是技术问题，而是让业务方能充分理解，这两种事务的关系，并在交互方式上做出调整，例如在界面上增加状态、进度等。**

根据 BASE 的思想，服务之间数据更新的方法调用，最好采用异步、消息机制，保证可用性、性能，一只性留给时间。

服务内部调用性能指标使用 QPS、TPS，服务间调用的设计，有两个不同的性能指标：

- 调用成功率，尽量不启用补偿机制
- 最终一致性时间，同步时间尽量小



**幂等**

想要做到最终一致的方案有很多，例如可靠消息模式、重试等。其中一个重要概念是，支持柔性事务的方法都需要设计为幂等，建议服务间调用的方法都设计为幂等。



幂等是一个数学与计算机学概念，幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。通俗来说就是一个方法多次执行不会产生副作用。数学公式表达如下：

![image-20200505194248188](02-ddd-foundamental/image-20200505194248188.png)

HTTP 协议中 GET、PUT、DELETE 等方法往往都是幂等的，除了 GET 这种天然具有幂等特性的方法外，分布式系统中对数据更新的调用也需要设计为幂等，用于实现最终一致性。



解决服务间一致性问题的方法总结：

1. 业务上做出取舍，或者划分服务时考虑，强一致性事务在服务内完成

2. 服务间使用柔性事务

3. 服务间有状态的方法调用设计为幂等

4. 服务间有状态的方法调用尽量走消息队列

   

#### 表关联问题



应用垂直拆分后面临的另外一个问题是实现表关联查询，例如某项业务在界面上有一个订单列表，订单列表中的一项是商品名称。按照一般的规律，商品和订单会被划分到两个服务中。

如何实现这个需求呢？

如果是单体、小项目，首选的方案就是订单表和商品表进行关联查询。不仅在分布式系统下，关联查询不可能实现，即使两张表在同一个库里，对于商品、订单这类大表联表的速度也非常慢。



##### 使用实时查询



服务化后，为了解决这个问题，走进的一个误区是通过 ID 来查询一个列表。为了构造出带有商品信息的订单列表，很多开发者会在分页后通过订单上的商品 ID 构造一个请求发送到商品服务，以此获取商品数据。为了避免循环调用产生 N+1 的问题，商品服务的开发者”贴心的“提供了一个通过商品 ID 数组批量获取商品数据的接口。

当这种接口大量出现的时候，拆分出来的服务又耦合到一起了，系统性能受损，且容易造成”雪崩“。会有大量的请求打到基础服务上，用户服务、商品服务、基础配置服务等首当其冲，需要注意这是分布式应用下的一种反模式。



在不得已且场景合理的情况下可以采用这种依赖方式获取数据，例如:



> 订单列表上有实时的物流信息，物流信息由物流服务提供，并且变化频繁。业务要求用户能看到自己的订单列表，列表中有一列为物流信息，包括：物流状态、物流单号、物流公司。

这种场景下，不得不采用将订单分页后通过 ID 到物流服务中获取，然后返回给前端。

即使是使用这种方式，也需要遵守一些规则。获取两个服务的数据并编排到一起，显然这个工作应该放到应用层，并尽可能使用异步的方式获取数据并聚合到一起。正是这个原因，Nodejs 以其天然的异步特性，被大量使用在应用层和接入层。如果使用 Java 则可以考虑 RxJava 等异步库来实现。

![image-20200516093818246](02-ddd-foundamental/image-20200516093818246.png)



同时，这种调用也需要进行熔断和回退。当物流服务 不可用时，应该即使中断连接，并依然将可用的数据返回给前端。界面上的表现是订单数据显示完整，仅仅是物流数据暂无法获取，对用户来说应用基本可用。

![image-20200516093947300](02-ddd-foundamental/image-20200516093947300.png)

不过，大多数场景下可以通过数据副本冗余和搜索服务解决这个问题。



##### 使用数据副本冗余和反范式

产生这个问题，实际上是受到数据库关系理论影响太深了，数据库关系理论可以有效解决数据一致性和冗余，但在分布式系统下不再适用。

我们来回顾下关系理论中最重要的数据库范式理论。范式理论在某种程度上代表着数据库设计冗余度，主流的范式理论有第一到第五范式，第三范式后面有一个巴斯-科德范式，可以看做 3.5 范式。随着满足范式增高，意味着数据库冗余降低，也就是表越 ”碎“，所以一般参考第三范式。



![image-20200516133902761](02-ddd-foundamental/image-20200516133902761.png)



1. 第一范式（1NF）。列职责单一，即表中每一列都是不可分割的，这是数据库设计的基本条件。学生表(学生姓名，学生基本信息)，用户基本信息中还有姓名。不满足第一范式，连关系数据库都不能算。
2. 第二范式（2NF）。所有字段都需要依赖主键，表中不应该存放和主键无关的字段。选课表(学号，姓名，性别，课程名，成绩)，学号与课程名称是主键。姓名依赖学号，但是和课程没有关系。应该拆分成学生表、选课表。不满足第二范式，本质是多个模式叠加一起了，会存在冗余以及部分记录中大量空字段。
3. 第三范式（3NF）。所有的字段都应该直接依赖主键，而不是传递依赖主键。基于第二范式的选课表(选课ID，学号，课程号，课程名，成绩)，选课ID是主键，学号、课程号、成绩决定了选课记录。课程名和选课 ID 实际上没有关系，课程名存在冗余。如果要满足第三范，需要将课程名拆分出去，通过课程号外键关联。



第三范式导致了学生和课程关联到一起，如果需要将学生和课程拆分成不同的服务，选课由课程服务提供，冗余***其中一个服务***的部分字段。在分布式应用系统下，可以通过反范式的思想来解决服务间的数据关联问题，单体系统我们一般将范式设计到第三或者巴斯-科德范式，分布式系统则应该考虑退化到第二范式，使用数据冗余和服务间同步。



![image-20200516135408376](02-ddd-foundamental/image-20200516135408376.png)





关于反范式应该注意两点：

1. 反范式不是没有范式，而是将高范式退化大低范式，通过冗余换联表成本。
2. 有些场景使用了冗余和快照是业务使然，例如订单中商品快照本来就不是商品，他们之间无需同步。即使在单体系统下也应该分开。这种冗余也不是反范式。



下面几个常见类似业务场景：

> 1. 某电商系统将订单和商品拆分为不同的服务，但是业务要求订单列表中需要显示商品名称。
> 2. 某大型网站提供了用户认证 SSO 服务，且拆分了单独的用户服，在某管理后台应用中，需要显示已经登录的用户列表和用户基本信息。
> 3. 某电商系统将订单和支付拆分为不同的服务，但是业务要求订单列表中需要显示支付状态。

通过 DDD 思想来分析，业务场景 1，订单中的商品和商品服务中的商品明显不是同一个概念。关于二义性的问题，我们在之前的文章中也讨论过，在不同的上下文下会存在二义性，通过发现二义性能建立合理的模型。这里的商品应该作为订单服务中订单项上的商品快照存在，设计为数据冗余。充分分析实际的业务问题，自然就解决了冗余关联的问题。类似的场景还有收货地址、票据等，这些对象都可以使用 DDD 中的值对象来设计，利用不可变性，让代码更直观。

![image-20200516100017610](02-ddd-foundamental/image-20200516100017610.png)



对于业务场景 2 属于常见需求，但是领域建模比较难的部分。很多系统都会提供认证服务，在认证这个上下文中，模型的本质是认证后的用户而非用户本身。因此往往是 token + 用户快照，不过并不是持久化到数据库中（往往是 redis ），所以在线用户列表并不需要去关联用户表，数据的一致性在用户重新登录后完成。



![image-20200516100927239](02-ddd-foundamental/image-20200516100927239.png)



对于业务场景 3 不能简单套用业务场景 1、2 。订单中需要冗余支付状态信息用于在订单服务中使用，但是对于这类需要服务间更新的冗余数据来说，可以借助在《分布式事务设计》部分谈到的最终一致性完成。不需要实时的访问订单服务，而应该采用同步和推送的方式，将支付服务中的状态同步到订单服务。

![image-20200516141244461](02-ddd-foundamental/image-20200516141244461.png)



在充分对业务分析的场景下，这种方式优势明显：



1. 查询性能高，不需要跨服务查询，缓存策略简单
2. 不需要熔断，没有雪崩效应
3. 便于业务统计分析，数据统计的成本低



当然，并不是所有的业务都能满足条件去实现这种设计，需要具备一些条件：

1. 业务天然具有分离性，典型的就是商品快照、收货地址、发票、单据
2. 业务上不完全分离，但能接受一定程度的延迟，对实时性要求不高，可以通过最终一致性同步过来。例如商品服务和供应链服务。



还有一些陷阱需要注意：

1. 盲目冗余，被冗余数据和当前服务完全没有关系。例如用户是否有折扣由积分阈值决定，积分可以动态增加和减少。有可能业务需要用户列表中显示有无折扣，但是折扣信息和用户完全不相关，这种情况也不要冗余。
2. 延迟要求较高，在前面的例子中物流信息变化十分频繁，并且业务上对延迟接受度低，也不要设计为冗余。



##### 使用搜索引擎解决复杂查询



解决两个服务的问题，有时候可以引入第三个服务来解决。我们来看下面的场景：

> 一个社区应用，用户发帖时间达到一定可以领取荣誉勋章，该系统将用户信息和成长体系分为两个服务。现在有一个需求是管理员需要根据荣誉勋章或者用户名进行搜索，并显示到一个列表上。同时类似业务也有可能出现在用户侧。

这个场景有两个特点。第一，不满足冗余设计的条件，荣誉勋章输入成长体系的一部分，这个服务和用户服务不太搭边。第二，需要跨服务搜索，且搜索会很复杂。



这种场景下实时查询和冗余设计的都不是很方便解决这个问题，好在可以通过搜索服务来解决这个问题。



![image-20200516103402240](02-ddd-foundamental/image-20200516103402240.png)



开源成熟的搜索引擎 Elastic Search 在互联网公司广泛应用，用于解决服务垂直拆分后的查询问题非常实用。通过创建多个 Elastic Search 的索引，可以满足各种不同的查询需求。



使用搜索引擎会造成项目的运维成本上升，带来好处同时也需要考虑成本。另外真实项目中，服务间数据同步失败，最终一致性丢失这种问题始终存在。搜索引擎应该只拿来做搜索，不应该获取搜索引擎中的数据直接应用于交易业务。用户从搜索引擎获取的列表，然后根据该条目操作退款等业务，即使条目中含有相关数据，也应根据关联字段实时访问服务获取最新正事数据，保证强一致性。



总之解决表关联问题还是需要转换关系型数据理论和分布式系统下的两种思维方式，灵活应用。跨库联表等技术显得非常不自然，同时在性能、业务规则上都面临挑战。



#### 分布式授权设计



应用垂直拆分后，面临的另外一个技术问题就是分布式授权问题。实际上 OAuth2 非常成熟，互联网的分布式授权体系基本都是基于 OAuth2的，使用分布式会话机制实现的 session 共享不能算严格分布式授权。讲解 OAuth2 的文章非常多，这里简单回顾一下，细节请参考相关资料 ——  之前的博客 [细说API - 认证、授权和凭证](http://www.printf.cn/index.php/archives/api-authentication-authorization-credential.html)。



OAuth2 有四个角色：资源所有者、资源服务器、授权服务器、客户端。

- 资源所有者（Resource Owner）。通俗来说就是需要授权的用户。
- 资源服务器（Resource Server）。这个比较好理解就是提供资源或者业务能力的服务器。
- 授权服务器（Authorization Server）。提供授权、发放凭证、检查凭证的服务器。
- 客户端（Client）。发起授权请求的服务器。



OAuth 2  主要解决了两个问题：

- 在不传递用户口令情况下让用户获得权限通行证。这个是通过服务间传递一次性授权码的方式代替密码传递实现的，基本原理比较简单：用户访问应用服务，应用服务去资源服务器拿资源，被要求授权。用户被跳转到授权服务，并使用密码请求授权服务器，授权服务器生成一次性授权码，跳转回应用服务。应用服务通过一次性授权码去授权服务器换取资源服务认可的凭证。
- 让分布式系统中各个资源识别访问者是否有权限访问。资源服务器提前注册到授权服务器，通过凭证去授权服务器检查是否有效，并获取角色信息。



基本的逻辑如下：





![oauth.png](02-ddd-foundamental/3686456467.png)



实际上，OAuth2 有主要 4 种模式，解决不同场景下的问题

- 授权码模式（authorization code）。通过一次性授权码，在无密码传递情况下获取授权。

- 简化模式（implicit）。没有应用服务器，客户端充当应用服务的角色，授权服务器直接把权限给客户端。

- 密码模式（resource owner password credentials）。应用服务器和授权服务器彼此信任，通俗来说密码模式就是走公司自己的授权服务，授权码模式走第三方授权。用户直接在应用服务输入密码，应用服务传递密码给授权服务器。

- 客户端模式（client credentials）。和用户授权无关，解决服务之间访问的问题。也就是常说的 AK/SK 授权，识别来调用你服务的来源是否合法。



##### 匹配 OAuth2 权限角色

在 OAuth2 实际应用中，有一个问题没有解决。应用垂直拆分后，那些服务分别充当 OAuth2 中的角色呢？我们回来之前的复杂问题，收银系统。当时为了简单，省略了用户服务和认证（IAM）服务，为了画下这张图，省略了一些元素，重点突出授权方面的内容。



![image-20200516150054993](02-ddd-foundamental/image-20200516150054993.png)





这个图还是看不出我们应用中那些是资源服务器、那些是应用服务器、认证服务器。我把图修改为半透明，并映射相关信息。

![image-20200516151440735](02-ddd-foundamental/image-20200516151440735.png)



通过 DDD 和 OAuth2 的结合，可以清晰地将 DDD 中的各种角色映射到 DDD 分层模型上。总结如下：



- DDD 各种应用服务，需要实现为 OAuth 客户端。

- DDD 各种领域服务一般设计为资源服务器。

- 授权服务器需要既要提供一个 DDD 概念上的应用层和领域层，可以部署到一起发布。

- 用户服务既要充当授权服务的资源提供者，实现用户登录。又要充当资源服务器，需要被权限管理。是一个比较特殊的互为依赖的关系，为了破解这个死循环，所以往往系统管理员都内置在数据库中。

- 系统内部一般使用密码模式简化授权流程。

- 如果需要提供一个开放的授权服务，授权服务器需要支持授权码模式。

- 服务之间的信任问题使用客户端模式，通过 AK/SK 访问，在很多公司内部叫做 ”集成账号“ 调用。

- 主流的实现上一般设计了认证服务和用户服务。用户服务负责用户、权限、部门等数据管理，认证服务负责 token 的分发，权限校验，绑定第三方登录等职责。

  

##### 拦截器应该放到哪里？

除了搞明白 DDD 分层和 OAuth2 角色映射关系之外。DDD 思想还可以回答另一个问题：访问控制应该在哪里完成？用户获取到凭证后，授权服务器确实可以校验凭证，那么谁来负责访问控制（ACL）呢？接入层、领域层、还是应用层？



为了回答这个问题，我们需要将权限分为两种情况：



- 方法级别的功能权限。解决的问题是，我能做什么。
- 数据权限，角色和对象之间的权限。解决的问题是，我能对什么数据做什么。



我们发现，功能权限不正是应用层的职责吗？应用层定义某个角色能完成一个独立的业务职责，也就是 use case。像添加商品、删除商品，都是一些 use case。那么这些权限控制放到应用层非常合适，应用层可以简单地在方法前面加上注解就可以实现。

```java
@PreAuthorize("hasRole('ROLE_ADMIN')")
public void addProduct(){
}
```



数据权限则没有那么简单，有两种声音：

1. 所有的权限都应该集中控制，数据权限也不例外，不应该放到领域层，应该尽量前移。在网关中完成认证和授权，请求进入系统内部后无需再检查权限。
2. 数据权限和业务相关，应该留给领域层决定，例如删除文章，需要有业务逻辑实现删除的是谁的文章。或者满足一定规则，比如删除共享给我编辑的文章。

在趟过很多坑，以及和大量资深工程师交流后，我是第二种声音的坚定支持者。原因有几个：

1. 不是所有的数据权限都能容易的被统一拦截器拦截实现，这个想法很美好，但是很不现实。
2. 用户对象的权限，本质上是一种业务规则，应该属于领域服务中来完成，否则大一统的数据权限成本高昂。非常简单的例子：有一个协作工作系统，一篇文文章可以由一个团队的成员编辑、删除。如果放到应用层，根本无法通过一个注解完成，因为有隐藏的业务规则存在。这种规则在 DDD 中可以使用 specification 模式来描述。



##### 权限设计的经验

1. 通过 HTTP 请求的方法来设计拦截器，因为很多权限不是以 HTTP 请求为粒度设计的。另外权限应该同应用层和领域层有关，接入层只起数据编解码、转换的作用，拦截器不要放到接入层。
2. 权限设计过于复杂，例如用户对一个集合部分数据有权限，部分无权限。业务往往要求 ”无权限即不可见“。但是这样做成本非常高，如果设计成上面方案 1 之后几乎没有能力扭转局面。这种场景会带来分页、过滤、统计等各种问题，建议从业务上避免。
3. 通过 HTTP  header 传递权限信息。服务之间的权限信息不要侵入业务方法，与之类似的还有语言、版本、trace id 之类的信息。
4. 用户密码错误，不要提示密码错误，应该提示”用户名或密码错误“。防止用户名被嗅探，被账户注册机等灰产盯上。



##### 分布式授权的性能问题

分布式授权往往会出现性能问题，每一次请求资源服务器都会拿到 access_token 后去认证服务器校验是否有效。在 Spring Security 中默认使用 RemoteTokenService，字面意思就是通过远程访问进行校验，通过 HTTP client 访问认证服务器。OAuth2 RFC 规范文档叫做 Introspection，定义了相关规范。

每一次远程调用意味着性能的浪费，为了消除掉这次远程调用，可以使用两种方法：

1. 直接访问 token 存储源，Spring Security 设计有 RedisTokenStore。不过这种方式违背了分布式系统的初衷，可以在内部系统酌情使用。
2. 使用自包含凭证，也就是 JWT（Json Web Token），Spring Security 设计有 JwtTokenStore。通过使用 Token 自身携带的凭证进行鉴权，可以较好的提高效率。



使用 JWT token 有两个注意事项：

1. JWT 因为自包含的特性无法做到撤回，解决的办法是通过 redis 设置一个黑名单，redis 过期时间和 token 比 token 的过期时间稍长即可。另外也需要给 access_token 设置一个合适的过期时间，一般在 5 - 10 分钟。
2. JWT 本质上是签名而非加密，Json Web Token 是 Json Web Signature 的应用。JWT 由消息体 + 签名构成，实际上就是结构化的 HMAC 签名方法。因此不能将一些敏感信息放到 JWT 消息体中，消息体只存放一些必要信息，并用于验证签名是否有效。如果需要更多用户信息，需要从用户服务获取。



![image-20200516221603716](02-ddd-foundamental/image-20200516221603716.png)



总之，应用垂直拆分后解决授权问题主流的方法是 OAuth2 + OpenID（OpenID 是一种基于授权的认证机制，可以参考相关资料）。OAuth2 只提供了一个授权模型，DDD 可以指导那些服务可以设计为客户端、资源服务器、授权服务器，根据 DDD 对系统分层可以得到一个映射关系，从而梳理出合理的权限系统。最后，分布式授权也会带来性能问题，我们可以通过 JWT 来解决这个问题，JWT 只是一种凭证格式，不是授权机制，应注意避免滥用。





#### 团队划分问题



前面提到过，促使公司将应用垂直拆分的一个原因是团队工作在一个项目上，团队过大无法展开。虽然将应用拆分的原因有很多，但是因为团队过大是所有原因中最被低估的一个。互联网应用往往是因为人多才拆成几个服务，而不是因为是几个服务所以才人多的。三五个人几条枪，被大公司忽悠，一个小项目拆成了十几个服务，这种技术很”吓人“的项目往往结局也很吓人。

刚入行带我的老板是从一家大公司出来创业的，随着团队扩大，他老挂在嘴边的一句话是，”一个50人以上的团队是没办法管理的“。当时不以为然，后来工作久了，参与过数百人一起开发的电商系统，经历过一个 Java 团队就有30 人的项目。

深以为然，甚至更为悲观，认为超过 15 人的团队都是难以被管理的。如果是敏捷团队，人数过多会很麻烦。敏捷有很多实践，有站会、codereview、计划会议、回顾会议等需要全体参与的会议。10 人以上的团队都难以让站会在 15 分钟内结束，codereview、回顾会议在 30 分钟内结束。超过这个时间，还要不要写代码修 bug 啦？

对于一个大型项目来说，服务化正是为了解决这个问题。通俗一点，团队划分的问题就是谁和谁坐在一起的问题，比较合适的人坐到一起工作效率更高不是吗，对于互联网公司而言，组织架构需要和技术架构适配才能取得最好的效果。回答这个问题，我们需要先看下各种公司的组织架构形式。



##### IT 行业企业组织架构类型

一些管理书籍将组织架构分为：金字塔式、扁平组织架构、矩阵制组织形式。对于互联网行业的公司来，我用更为通俗的说法，和现实中的经历，重新划分了一下：

- 大部门式的组织架构。相同职责的人被收集到一起，形成了前端、后端、测试等大部门，典型的科层制的组织结构。
- 矩阵制组织形式。大部门式的组织架构上根据项目再动态划分，行政管理和项目双线制。
- 自由市场式的组织架构。这个公司就是一个大市场，各个单位按照一定形式混编，甚至管理团队也作为一个单位为公司提供服务。
- 分形组织架构。基层由较全功能的小团队构成，多个小团队构成一个中层大部门，最后各个大部门构成整个公司。整个公司可以看做大型企业，每个大部门可以看做一个中型企业，每个基层团队可以视为一个创业公司。



![image-20200517161135173](02-ddd-foundamental/image-20200517161135173.png)





##### 大部门式的组织架构



有一些公司是按照工种来划分的，客户端、测试、产品经理被分到不同的部门。我曾在一个这种类型的公司任职，客串过前端部门和后端开发部门。因为业务决定了后端开发的工作量远多于客户端和移动端开发，因此部门之间极不均衡。



![image-20200517104005548](02-ddd-foundamental/image-20200517104005548.png)



我们有 40 人的后端开发部门，10 人的产品经理部门，30 人的测试部门。这些人的工作部门领导分配，任务的流动方式是市场领导 -> 产品经理领导 -> 设计和交互部门领导 -> 各个开发部门(前端、后端、客户端、移动端) -> 测试部门领导 -> 运维部门领导 -> 市场部门领导。

这种工作模式本质还是一个大的单体团队 + 瀑布的工作流，其组织是一个金字塔形式，行动缓慢。这种组织架构带来了另外一个问题，团队扩张非常困难。这种困难和我们在技术上的容量瓶颈类似，技术上应用的水平扩展无法突破数据库的瓶颈，这种组织架构的瓶颈无法突破部门经理的负载。



##### 矩阵式架构

大部门式的组织架构是从亚当斯密的社会化分工理论就开始了，制造业尤为明显。曾参观过富士康、自行车制造商捷安特的工厂，基本都是以大部门式的组织方式。银行、传统行业转行的 IT 公司很多也是大部门式。这种组织形式劳动密集型企业没有问题，但是对智力密集型企业缺点越来越明显。知识性工作，工作者之间需要大量的交流。相关的人，”坐到一起“ 永远是效率最快的交流方式。

随着软件工程的发展，项目管理在软件公司也像在制造业一样蓬勃发展。于是很多公司开始使用项目制，但是项目制的缺点和大部门式完全相反，项目组成员能有效沟通，但无法传达行政指令。行政管理总是不可或缺的，比如涉及绩效、涨薪等问题，项目制很难解决，几乎没有纯项目制的公司。

于是出现了项目、行政部门双轨的组织形式，这种形式能比较符合软件工程的需要。



![img](02-ddd-foundamental/u=3842307838,349803241&fm=26&gp=0.jpg)



传统的软件行业更像是来料加工的制造业，客户需要一个软件就启动一个项目，开发完成后释放掉这个项目。但是现代的互联网行业更像是一个服务业，软件开发需要源源不断的开发、修复问题和提供更新。于是矩阵式架构就留给了软件技术服务和解决方案公司了。



##### 自由市场式的组织架构

互联网软件开发需要源源不断的开发、修复问题和提供更新，按照时间或者事件启动的软件项目越来越鸡肋。软件开发往平台化、服务化发展。互联网公司项目经理的话语权慢慢移交给了产品经理，软件开发变成了一个持续的行为。

相应的，互联网公司的组织架构开始调整为小型敏捷团队。响应需求和提供服务变成了其组织的目标，彻底区别于”来料加工“型的组织方式。这种组织形式需要很多灵活的小团队和一个中心来调度协调，于是变得越来越扁平。

很多公司推崇的扁平式组织架构，与其说扁平不如说是自由市场式。谁能为这个企业的内部产业链上提供服务就有机会拉起一个团队，如果能在公司外找到又好又便宜的供应商就外包出去，自由市场就是这么残酷。有人制作过一张苹果公司的组织架构图，非常有趣，围绕着 CEO 的是各个团队领导以及背后的团队。



<img src="02-ddd-foundamental/image-20200517161736294.png" alt="image-20200517161736294" style="zoom: 33%;" />





扁平的另外一个含义就是各个单位之间相对独立，每个单位直接向核心层汇报。每个团队的独立性使之可以让核心层快速调用，当然每个团队也更容易被替代。不过需要注意的一点是，组织架构扁平的出现可不是公司为了给雇员提供一个轻松而没有压迫的环境，而是由他们业务决定的。

**因为这样比较省钱**，充分体现了市场经济的哲学原理。

披着”市场经济下“外衣的扁平架构就是完美的组织架构了吗？如果是这样，经济危机就不会出现了，扁平组织架构的公司就能万世长存。扁平意味着权利下放到基层，权利结构分散和多样。团队之间虽然可以平等对话，但是会出现互相不正常竞争、KPI 至上的问题。团队之间在每个财年争抢预算，各自为政。

这种组织架构要求一个精神领袖，或者强大的平台，否则难以约束基层的权利。当缺乏精神领袖时，这种系统并不稳定，举个不恰当的例子是周天子衰败的春秋时期，以及失去向心力的民国时期。至于民国时期的状态，可以了解下《中国近代简史》，下面是一张军阀分布图。



![img](02-ddd-foundamental/u=1774625344,1844853139&fm=11&gp=0.jpg)



##### 分形组织架构

当人类有组织后，大部门式的组织架构就有了，这是一种朴素的组织架构方式；那么自由市场式的组织架构是IT 行业特有的吗？拿我们近代史中的故事。二战时期的步兵往往就是大部门式的组织架构，这符合那个时期的军队特征。不过日、美军已经有全功能小队作战的思想，小范围用于山地特种作战。这个和全功能的敏捷团队有一点类似，有一点自由市场式的味道。

幸运的是我军走了另外一条路，也就是我们要聊的**分形组织架构**。当时我军在装备、人员上都和日军差距巨大，但好在产生了”三三制“这种班组突击战术，后来推广全军的组织架构上。三人构成一个战斗小组呈三角进攻队形，每名士兵分工明确，进攻-掩护-支援。三个战斗小组组成一个班，班长、副班长、二组长，各带一个战斗小组行动。一个排由三个或多个班组成，一个连由三个排组成，全军依次类推。这种组织形式的好处是，分工明确但又有向上信息传递的通道，不那么依赖中心，能在战术穿插过程中快速重新组织起来，形成战斗力。



![img](02-ddd-foundamental/u=525484661,3436452463&fm=26&gp=0.jpg)



分形是数学上的概念，它的局部总是和全局相似，自然界无处不在：雪花、树干、晶体等等。这种组织形态类似数学上的分形，我们暂且把这种形态叫做**分形组织架构。**



![img](02-ddd-foundamental/u=1698236527,3389317372&fm=26&gp=0.jpg)



当然”三“也不是绝对的，可以由三人或者多人构成，现在由于兵种更加多样，现在军队也不是完全”三三制“了。不过”三三制“这种思想还广泛存在，影响了很多机构、企业的组织形式。

![image-20200517194703512](02-ddd-foundamental/image-20200517194703512.png)



曾经很长一段时间里，对国内一些大型的互联网公司的组织架构感到疑惑。他们既不像大部门式的组织架构，也不像自由市场式的扁平架构。当一个公司大的可怕时，这些公司更像一个市场而不是一家公司，现在的理论仿佛不能完全描述他们。

三四个后端、一两个前端、一个 UI 设计师、两个测试外加一个产品经理，这就是一个互联网公司最基层的一个敏捷团队，负责一个大产品中的一个服务，也是很多初创团队的配置。

三四个敏捷团队大约几十人左右，就可以负责一个完整的产品，这也是一个起步成功的小公司的配置。

三四个产品构成一个事业部，能负责一个公司一条产品线，这也是一个中大型公司的配置。最后，多个事业部构成了最终的大公司，当然这些团队还有可能是市场、法务、生产等其他角色。



这种形态已经是目前大的互联网公司主流形态，金山、百度、阿里等等。这样来看的话，分形组织架构的局部就可以看做自由市场式的组织架构。



##### 使用 DDD 指导团队划分

对于互联网企业而言，比较看好的是分形组织架构和自由市场式的组织架，因为我们基于 DDD 理论设计的分布式系统某种程度上也是分形结构。既然团队划分是为了服务技术架构，那我们又可以借助 DDD 的一些成果为团队划分帮一点忙了。

我们采用和《分布式授权设计》类似的套路，先把 DDD 的服务划分图做一些调整，然后再映射上团队划分图。再来解决一个一个细节问题。我拿最复杂的那张图做蓝本，并补充了分布式授权部分补充的授权服务。其实这张图还不够复杂，在真实的互联网公司往往还有支付、大数据、物流、售后服务等等。



![image-20200516232757864](02-ddd-foundamental/image-20200516232757864.png)



我们从 DDDD 得到应用的分层，然后划分出服务。根据康威定律，一个公司的组织架构和技术架构需要适配，当我们采用分布式系统划分了我们的应用后，传统的开发、测试大部门就不再适用了。

因此我们使用敏捷的工作方式和团队划分方式。这也是我们正在讨论的问题，根据我们服务的划分作为底图，初步得到我们的团队划分方式：

![image-20200516234815771](02-ddd-foundamental/image-20200516234815771.png)

作为敏捷团队，后端开发、客户端开发、移动端开发、前端开发、测试被打散到各个团队中。我将团队性质不同使用颜色区别了一下，以便于后面调整和阐述每种类型的团队成员组成部分。抱歉，因为这个图我还想保留 DDD 分层的信息，显得有点凌乱，我们会一步一步突出团队划分。



- 绿色， Deveops 团队，负责基础设施的开发和运维，提供开发、部署平台。负责维护测试环境、部署、日志、监控、代码质量检查、堡垒机、安全审计、数据库管理等。
- 红色，领域服务团队，负责领域服务开发、测试。可以由纯后端开发组成、QA为主。领域服务的 QA 负责 API 测试、集成测试、性能测试。
- 青色，应用团队，负责应用层和端侧实现。负责整合后端 API 实现端到端应用，团队由前端、客户端、后端开发或者全栈工程师组成。QA 负责应用端到端测试，确保最终交付质量。
- 藏青色，认证和授权团队，负责提供统一的认证和授权服务，也就是 SSO 服务。认证和授权团队一般都比较特殊和独立，因此单独一个团队。



这样一整理，我们发现每种颜色对人员的需求是不一样的，甚至需要自己独立招人。试试就是现在主流的互联网公司都是这样操作的，不仅需要独立招人，还有内部的人才市场。



那么，对于上面这个场景下的人员构成，我们再细化一下每个团队需要的具体角色。



![image-20200517220726961](02-ddd-foundamental/image-20200517220726961.png)



这种系统还有一个问题没有解决，每个团队相同的角色之间没有交流。每个团队有自己的 UI ，那么整个公司就没法统一；各个团队的工程师如果没有交流，整个公司的技术架构就是一团糟；BA 各自设计，业务逻辑只考虑自己的应用和服务，必然会造成逻辑上的矛盾。为了解决这个问题，有些公司创造了一个”委员会”的概念，由分形的上一级协调拉通。



这些委员会不是一个团队，而是由每个团队挑选出能“说的了话”的人共通参与，进行需求、设计、架构、测试评审的。



- 架构委员会。由后端开发、devops、各端（前端、IOS、安卓、PC）等和技术选型、方案、架构相关的人员参与。职责为参与方案评审、技术选型、安全评估、规范制定、技术演进等。有一些公司会提供单独的架构师职位，其实更多的公司作为架构师的前提是一个优秀的一线工程师。
- UI/UX委员会。由各个团队的 UI/X 组成，负责制定 UI 规范，设计系统。
- 测试委员会。由各个团队测试组成，负责制定测试策略、测试用例编写规范。
- 业务需求委员会。由各个团队业务组成，负责拉通业务需求和产品设计，保持各个应用的业务逻辑的一致性。



当然如果是在一家大的电商公司还会有自己的支付、物流、大数据、营销、财务平台，除了 IT 部门外还有市场、销售、法务，根据我们的分形理论，他们可能存在于另外一个平行世界里。



##### 总结

聊完这些，对于一个大团队是否可以被管理又没有那么悲观了。当人类开始有能力成群结队用石头击败野兽的时候，管理就出现了。推动人类社会进步的是火吗，其实更应该是建立在语言之上的社会组织能力。800年周王朝建立在封建社会对奴隶社会的优越性上，资本主义的萌芽不仅仅是因为蒸汽机，更可能是社会化大生产的新型组织形式。

一个大的公司真的应该重新审视组织和技术两个方面，组织架构的创新也许比科学技术的创新更重要，团队划分的问题实际上是一个如何解放生产力的问题。





#### 领域层模块之间的依赖关系



解决了这些问题，DDD 可以很好的落地使用了，那么关键的问题是，服务该如何拆分呢？接下来我们讨论如何进行服务拆分。



### DDD 服务拆分基础

前面讨论了很多架构方面的问题都是基于一个前提，无论是准单体还是分布式系统，服务之间需要合理的拆分。那么怎么做到服务之间合理的拆分呢？

首先，服务拆分需要满足四个原则。



**原则一：服务大小适中**

服务拆分太大起不到垂直拆分的价值，拆分太小后面的几个原则难以满足。



**原则二：服务模块之间松耦合**

如果有强耦合没有必要拆分。



**原则三：领域对象有独立的生命周期**



**原则四：强一致性事务在一个服务完成**



DDD 把解决服务拆分这类宏观问题叫做**战略设计**。



- 组件、模块、服务
- 战略设计
- 依赖是指什么？
- 子域和上下文
- 事件风暴简介



### 选择合适的分布式级别



2019 年是一个奇幻的一年，太多的互联网公司开启中台计划，当然这种”吓人“的技术最终的结局也很吓人。创业公司大多数做的产品都不是真正意义的商用系统，而是快速原型验证（POC 或者叫 MVP），微服务不是一个明智的选择。



分布式级别升高，或者叫架构演进层次往更复杂方向发展，往往是被业务逼出来的，而不是为了炫耀技术实力。



中型公司做微服务是因为代码仓库已经大的无法快速构建，以及团队大的甚至无法协作；大公司做中台，是因为有无数个应用产品需要复用底层逻辑；小型创业公司应该选择自己的逻辑和开发模式。



## 编写一个 DDD 风格的准单体系统



通过一个例子分析

- 聚合根持久化
- 读模型
- 跨聚合操作
- 跨上下文操作
- 为微服务化提供可能



如果不能编码实现一个软件，那么上面说的内容就全部没有意义。使用 DDD 做完服务拆分后，对应到准单体系统就是各个模块。

我们选择主流的技术栈 Java + Mybatis 来实现它，即使你的主力语言是 PHP、Go 或者 Nodejs 也没关系，你只需要了解 Java 的一些基本概念，在有代码基础设施的情况下，实现起来不是难事。





## 小结

本章通过餐饮软件的例子介绍了 DDD 的一些基础概念聚合根、实体、值对象，对上下文区分、二义性和统一语言的重要性做了说明，以及讲解了 DDD 是如何指导我们实际编程实践的。

最后我们编写了一个热身小项目，了解 DDD 在小型项目中也可以使用，但是因为分层的原因显得啰嗦。你可以认为这是一个快速验证业务可行性的最小实现（POC）。

一个中大型的互联网产品设计复杂的多，我们往往在谈架构的时候忘记了一件事，就是业务和需求分析，业务输入决定了我们如何设计我们的系统。

所以我们重新起航，在后面的内容中选择高级别的分布式系统，以微服务架构为蓝本，使用 DDD 的一些设计方法来划分我们的服务，设计出我们的架构，并通过遗留系统重构的方式实现它。
