
微服务是怎么被划分出来的？
===

## 微服务划分方法论

微服务发展至今，已经不是一个前沿概念了。越来越多的公司已经在使用或正在准备采用微服务。尤其是这2-3年间，我参与的项目已经没有不是微服务的了。

同时，微服务已经有非常多成熟的实践，大量开源的微服务框架可以供我们选择，Spring Cloud、Dubbo等框架让我们对微服务的实践难度和成本大大降低。有大量的技术书籍在讨论微服务、分布式架构等技术的具体实现方式，一个公司想要实践微服务已经非常容易了。

我在参与和实践了大量微服务项目过后，让我困惑的往往不是某一个具体技术的选型，服务发现、调用链追踪都有成熟的开源组件帮助我们完成。而让我苦思冥想的另一个问题是：如何把一个单体应用拆分出更合理、更有弹性的微服务架构？

当我查阅企业架构相关的书籍时，了解到IT系统架构不仅需要应对技术架构的挑战之外，还需要应对业务架构方面的挑战。如何从业务的角度出发设计出更加贴切企业战略和业务需求的架构，在适合业务发展和避免过度设计之间取得一个平衡？

在过去大量的实践中，我们的架构师关注在软件的基础设施上，云、数据库分库、数据库分表、集群、负载均衡、认证和授权等这些技术实践上。对于设计一个系统而言，做的第一件事就是关注数据库表、字段、关联。

我们往往忽略了一个非常重要的环节，就是领域建模或者叫做业务架构，这个环节被隐藏到架构师或者技术 Leader 的经验决策中了。在单体应用时期这个问题不是很明显，订单和商品需要设计多少个表、有什么字段、表之间的关联怎么样，富有经验的开发者都能做出合适的决策。

然而在微服务的时代，我们遇到的问题就变成了，订单和产品是否应该划分到两个微服务中，每个服务的职责和边界在哪里，服务之间的API怎么设计，服务之间的依赖关系是什么样子。这部分的架构设计看起来好像和我们做技术选型时考虑的角度不太一样，不再关注技术细节，而是关注于业务细节。相对于处理一些非功能需求，这部分工作对抽象能力、业务分析能力、面向对象能力有了更高的要求。

软件设计是一个复杂的系统问题。于是我们在架构设计中，有两类问题需要解决：同非功能需求相关的技术复杂度，以及和功能需求相关的业务复杂度。

非功能需求是指那些跨功能的通用需求，例如安全、性能、并发等，围绕着这些问题我们发展出了各种解决方案，例如OAuth、缓存技术、负载均衡等，但是这些复杂问题其实和业务是没有关系的。我们把解决这类复杂问题的架构思维叫做技术架构。

功能需求是指用户能操作的使用的需求，例如登录、下单、申请退款，这些复杂问题实际上和采用的技术关系并不大，从编程语言、框架、数据库上来说， 都能完成这些业务要求。无论是 Java、.Net、PHP 以及是否采用微服务，都不妨碍我们完成业务功能。

业务复杂度也是软件开发过程中非常重要的一部分， **我们暂且把解决这类问题的思维方式叫做业务架构**

技术架构大量依赖于实践和经验，在行业内具有相当的通用性，可以采用大量的开源方案。而业务架构解决的问题是如何分析业务逻辑，正确的对业务进行抽象，然后得到合理的软件架构。业务架构非常强的依赖于面向对象的思想和高度的抽象思维，是一线应用开发者主要思考的问题，同公司的产品相关，通用性非常弱。


| -              | 技术架构           | 业务架构           |
| -------------- | ------------------ | ------------------ |
| 实践           | 负载均衡、高可用   | 服务划分、应用解耦 |
| 对开发者的要求 | 主流解决方案的经验 | 抽象、逻辑分析能力 |
| 解决的问题     | 技术复杂度         | 业务复杂度         |

当然，这两种架构思维并不能彻底分开。讨论这两种架构的不同可以帮助我们换种思路去看待架构问题。

业务架构不应该限制于技术细节，在做业务架构的时候应该和我们的业务专家讨论，分析业务在逻辑上的可行性或者矛盾。技术架构则不应该和业务过多的捆绑，架构师讨论这些问题的时候，应该听取某个技术领域中的专家意见，例如更换一种缓存策略是否能大幅度提高性能问题。

另外一个方面，技术架构应该是服务于业务架构，而非凌驾于业务架构之上。尽可能的将最优的技术资源花在核心业务逻辑上，优秀的武器应该首先能打中靶子。

我经历过一个失败的项目。团队致力于开发一个基于云的餐饮管理软件，商户可以非常方便的集中管理连锁餐饮门店 

[TODO]


## 使用 DDD 进行业务架构


微服务时代介绍业务架构方面的资料还非常少。有大量资料讲解如何搭建一套消息中间件，但是很少有资料讲我们需要多少个微服务？微服务架构中，订单和商品一定要两个服务吗？这样划分的依据是什么呢？

所幸，软件开发领域中技术的发展都是有迹可循的。被合理划分成多个微服务的分布式系统，在逻辑上和解耦良好的单体系统是一致的。大家可能都有这样的体会，因为单体应用某些模块已经被良好的解耦了，在划分成多个服务时显得非常自然。例如一个企业应用中，配置管理往往相对独立，一般作为单独的模块设计。在划分微服务的时候很容易划分处理，但是订单、商品、支付等部分往往依赖关系错综复杂，调用关系千丝万缕，做微服务划分时显得艰难。

所以，良好的微服务设计，很重要的一部分就是如何对业务的建模和分析，在逻辑上有一个清晰的关系。

好在十多年前，Eric Evans 提出了“领域驱动设计”，也就是我们常说的 DDD （Domain-Driven Design）。通过 DDD 一系列方法可以从业务出发

领域建模
===


## 事件风暴工作坊简介

EventStorming 工作坊是 Alberto Brandolini 发明，一种用于领域驱动建模的工作坊形式，中文环境下又被称作为事件风暴工作坊。

工作坊的英文名称是 Workshop 通俗来说就是找一波人在一个大屋子里开会，进行研讨活动。和培训不同的是，工作坊一般没有讲师，也没有固定的内容。工作坊一般会有一个主持人，有些环境下又被称为催化师，负责工作坊的流程和推动，但内容是所有参与者共同完成的。

通过事件这个视角探索一个软件系统中的关键数据流动，然后提取和抽象出共同的对象或实体，从而为软件设计带来极大的便利。这是事件风暴工作坊的基本逻辑。例如通过和业务人员探索“订单已提交”、“支付已完成”、“用户已通知”，从而抽象出 “订单”、“支付”、“通知”等相关模型。

事件风暴工作坊的另外一个特点是，让业务专家和开发人聚到一起研讨软件的设计，它聚焦于业务而非具体的技术。如果亲临事件风暴工作坊的现场，你一定会被业务专家和开发人员的协作感到震惊。开发者往往选用 UML 作为建模的工具，然而哪怕是最轻量级 UML 工具也很难让多个人协同操作。另外，很少有业务人员能了解或者知道怎么使用 UML，因此 Alberto 在遇到这个问题时，采用了最简单直接的方法，用会议室的整面墙壁和便利贴代替屏幕和鼠标。

本篇描述的事件风暴工作坊是根据具体情况不断调整和改进过后的形式，并增加了为微服务设计相关的内容，已经和 Alberto 先生有较大出入。对 Alberto 先生的工作坊形式有兴趣可以访问  https://www.eventstorming.com/ 了解。


为微服务划分设计的事件工作坊基本分为三个阶段：准备工作、战略设计、战术设计

**准备工作**

1. 环境准备
2. 人员调度
3. 物料准备
4. 日程安排
5. DDD 导入培训
6. 检查准入条件

**战略设计**

1. 识别问题域
2. 业务场景分析
3. 事件风暴
4. 命令风暴
5. 识别领域模型
6. 识别限界上下文
7. 识别上下文关系

**战术设计**

1. 聚焦单个上下文，识别聚合
2. 识别聚合根、实体、值对象

特别的，为了承接事件风暴工作坊的产出，下面是一些微服务设计的后续工作，可以不在工作坊内完成：

1. 通过上下文关系进行微服务设计
2. 通过微服务设计API
3. 通过聚合设计数据库
4. 通过聚合设计代码包

## 工作坊准备

开始事件风暴工作坊之前，有一些准入条件，当这些条件不满足时，不应启动工作坊，强行启动可能不会带来有效的成果和收益。

下面是一份检查清单，稍后会详细解释：

- 工作坊的目标已经明确，确认当前工作坊是为了做重构还是设计目标方案
- 工作坊的范围已经明确
- 业务场景选定
    - 选择最长的业务场景
    - 可以由多个业务场景凭借
    - 选择业务重要性高的场景
    - 选择业务相关性强的场景
- 业务专家已经指定明确
- 技术专家已经指定明确
- 有初步的用户故事地图分析结果（可选）
- 澄清风险


## 战略设计

### 事件风暴

为什么要识别事件？程序=数据结构+算法，软件本身就是一台能通过特定算法并通过修改数据结构的虚拟机器。

因此软件系统可以理解为一种能通过特定响应外部操作进而修改自身状态的虚拟机器，这台机器的生命力来自于响应外部的操作。我们可以通过数据的流动来观察这台机器，那么“事件”就是系统状态改变的关键信息点。

下面是操作步骤：

1. 选定场景范围
2. 在墙上预留空间，根据场景在墙面顶部标出时间线
3. 识别事件，事件以完成时描述，例如 “订单已支付” 
4. 如果多个事件的触发存在条件，可以使用规则，规则代表系统中的一些条件。使用 “xxx规则” 描述
5. 按照时间线发散，补充所有事件
6. 完成一次事件梳理后，进行逆向检查，反方向验证事件是否合理。  
    1. “是否遗漏了事件？”
    2. “事件是否被默认合并了？例如订单已支付，应该还有支付已完成”
    3. “该事件是否一定需要存在？”
7. 重复以上步骤。

[TODO: 操作流程图]

事件风暴是整个工作坊中最重要的一部分。是否能合理的识别出事件，是工作坊成功地重要输入。其中，有一些概念难以理解，下面是我在经历大量实践的过程中总结的一些经验和要点：

- 事件可以理解为对系统状态的修改。
- 事件应该是独立和原子的。
- 事件使用完成时作为约定，标志着系统状态变化结束。例如：用户已注册。
- 避免使用无用的缀词，例如 XXX 已完成。
- 事件一定要前后匹配，这个环节挑战的是业务分析时逻辑是否严丝合缝。例如订单已完成，应该是由上一个事件支付已经完成触发的，否则开发时会缺少逻辑。
- 规则和事件的区别表现在系统中某个算法、逻辑判断还是数据状态的修改。例如验证通过注册成功，这其中包含了一个验证的规则，和用户已注册的事件。
- 这个阶段的事件和业务相关，暂时不要把技术带入
- 如果某些信息在场人员知识不足，或无法做出决定可以先跳过
- 完成一遍事件梳理后进行“逆向检查”
- 忽略现有实现，分析的是现有业务
- 任何对系统状态没有修改的的行为都不算事件。例如显示列表、鼠标滚动。除非系统需要关注用户行为，那么鼠标滚动就成为了事件，需要被考虑和建模。
- 注意不要遗忘和外部系统交互的事件，例如商品是从外部系统同步过来的，应该有“商品已获取”
- 如果是调用外部系统数据，应该使用 “xxx 数据已获取”。表明系统的状态被改变。


这个环节往往占据了这个事件风暴大部分时间，如何确认这个环节的产出是有效的呢？

在后面的环节中可以总结一些经验：

- 一个场景的事件应该是完整自洽的，订单已支付必然存在未支付的情况，通过正反面分析问题。
- 抓住规则，穷尽这个规则后面的所有的事件，例如订单支付成功、不成功、取消、超时等各种情况
- 抓住事件的前后关联，留意伴生事件，例如用户支付成功会不会有消息发送的情况。

最后，我们的工作坊应该是迭代式的，这个环节尽可能挖掘所有的事件，但是现实中即使富有经验的领域专家和业务专家，也无法因此穷尽所有的事件。因此我们必须承认我们会在后面的环节对事件进行调整，因此做好一定的准备。

### 命令风暴

## 战术设计





# 简介
Domain Driven Architecture book 

TODO: 中文名

致谢

- 文档构建基于 Pandoc
- 文档样式来源 [https://phodal.github.io/mifa](https://phodal.github.io/mifa)

参考资料
=== 
- https://xebia.com/blog/eventstorming-continuous-discovery-beyond-software-modelling/ EventStorming; Continuous discovery beyond software modelling
- https://www.jdon.com/50847 EventStorming 超越软件建模的持续发现
